import express from "express";
import { models } from "../models/Modelold.js";
import multiparty from "connect-multiparty";
import fs from "fs";
import path from "path";
import { validateAuth } from "../../middlewares/validationResultExpress.js";
import {
  list,
  create,
  createBatch,
  findById,
  remove,
  update,
  updateBatch,
} from "../controllers/funciones_standart.js";

// Función para crear directorios si no existen
const createDirectoryIfNotExists = (directory) => {
  if (!fs.existsSync(directory)) {
    fs.mkdirSync(directory, { recursive: true });
  }
};

// Middleware de multiparty con directorio dinámico y creación de directorios
const pathfile = (modelName) => {
  const directory = path.join("./uploads", modelName.toLowerCase());
  createDirectoryIfNotExists(directory); // Asegura que el directorio exista
  return multiparty({
    uploadDir: directory,
    maxFieldsSize: 50 * 1024 * 1024,
  });
};

const routerStand = express.Router();

const generateSchemaProperties = (schema) => {
  const properties = {};
  for (const path in schema.paths) {
    if (schema.paths.hasOwnProperty(path)) {
      const field = schema.paths[path];
      if (path !== "__v" && path !== "_id") {
        let fieldType;
        if (field.instance.toLowerCase() === "array") {
          fieldType = {
            type: field.instance.toLowerCase(),
            items: {
              type: "string", // Cambia esto según el tipo de elementos en tu array
            },
            description: field.options.description || `${path} field`,
          };
        } else {
          fieldType = {
            type: field.instance.toLowerCase(),
            description: field.options.description || `${path} field`,
          };
        }
        properties[path] = fieldType;
      }
    }
  }
  return properties;
};

const generateRoutes = (modelName) => {
  const Model = models[modelName];
  const path = modelName.toLowerCase();

  const schemaProperties = generateSchemaProperties(Model.schema);

  if (Model.isAutogenerated("get")) {
    routerStand.get(
      `/${path}`,
      validateAuth(Model, "get", `/${path}`),
      async (req, res) => {
        const populateFields = req.query.populate
          ? req.query.populate.split(",")
          : [];
        const response = await list(modelName, req.query, populateFields);
        res.status(response.status).json(response);
      }
    );
  }

  if (Model.isAutogenerated("get")) {
    routerStand.get(
      `/${path}/:id`,
      validateAuth(Model, "get", `/${path}/:id`),
      async (req, res) => {
        const populateFields = req.query.populate
          ? req.query.populate.split(",")
          : [];
        const response = await findById(
          modelName,
          req.params.id,
          populateFields
        );
        res.status(response.status).json(response);
      }
    );
  }

  if (Model.isAutogenerated("post")) {
    routerStand.post(
      `/${path}`,
      validateAuth(Model, "post", `/${path}`),
      pathfile(path),
      async (req, res) => {
        const response = await create(modelName, req.body, req.files);
        res.status(response.status).json(response);
      }
    );
  }

  if (Model.isAutogenerated("put")) {
    routerStand.put(
      `/${path}/:id`,
      validateAuth(Model, "put", `/${path}/:id`),
      pathfile(path),
      async (req, res) => {
        const response = await update(
          modelName,
          req.params.id,
          req.body,
          req.files
        );
        res.status(response.status).json(response);
      }
    );
  }

  if (Model.isAutogenerated("delete")) {
    routerStand.delete(
      `/${path}/:id`,
      validateAuth(Model, "delete", `/${path}/:id`),
      async (req, res) => {
        const response = await remove(modelName, req.params.id);
        res.status(response.status).json(response);
      }
    );
  }
  if (Model.isAutogenerated("createBatch")) {
    routerStand.post(
      `/createBatch/${path}`,
      validateAuth(Model, "createBatch", `/${path}`),
      pathfile(path),
      async (req, res) => {
        const abortOnError = req.query.abortOnError !== "false";
        const response = await createBatch(modelName, req.body, abortOnError);
        res.status(response.status).json(response);
      }
    );
  }
  if (Model.isAutogenerated("createBatch")) {
    routerStand.put(
      `/updateBatch/${path}`,
      validateAuth(Model, "updateBatch", `/${path}`),
      pathfile(path),
      async (req, res) => {
        const abortOnError = req.query.abortOnError !== "false";
        const response = await updateBatch(modelName, req.body, abortOnError);
        res.status(response.status).json(response);
      }
    );
  }

  return `
components:
  schemas:
    ${modelName}:
      type: object
      properties:
        ${Object.entries(schemaProperties)
          .map(([key, value]) => `${key}: ${JSON.stringify(value)}`)
          .join("\n        ")}

tags:
  - name: ${modelName}
    description: ${modelName} managing API

paths:
  /${path}:
    get:
      summary: Retrieve a list of ${modelName}
      tags:
        - ${modelName}
      security:
       - Authorization: []
      responses:
        '200':
          description: A list of ${modelName}
          content:
            application/json:
              schema:
                type: array
                items:
                  $ref: '#/components/schemas/${modelName}'

    post:
      summary: Create a new ${modelName}
      tags:
        - ${modelName}
      security:
       - Authorization: []
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/${modelName}'
      responses:
        '200':
          description: The ${modelName} was successfully created
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/${modelName}'

  /${path}/{id}:
    get:
      summary: Get a ${modelName} by ID
      tags:
        - ${modelName}
      security:
       - Authorization: []
      parameters:
        - in: path
          name: id
          schema:
            type: string
          required: true
          description: The ${modelName} ID
      responses:
        '200':
          description: The ${modelName} description by ID
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/${modelName}'
        '404':
          description: The ${modelName} was not found

    put:
      summary: Update a ${modelName} by ID
      tags:
        - ${modelName}
      security:
       - Authorization: []
      parameters:
        - in: path
          name: id
          schema:
            type: string
          required: true
          description: The ${modelName} ID
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/${modelName}'
      responses:
        '200':
          description: The ${modelName} was successfully updated
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/${modelName}'

    delete:
      summary: Delete a ${modelName} by ID
      tags:
        - ${modelName}
      security:
       - Authorization: []
      parameters:
        - in: path
          name: id
          schema:
            type: string
          required: true
          description: The ${modelName} ID
      responses:
        '200':
          description: The ${modelName} was successfully deleted
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/${modelName}'
  `;
};

// Generar el contenido YAML para cada modelo
Object.keys(models).forEach((modelName) => {
  const swaggerContent = generateRoutes(modelName);
  const swaggerDir = path.join("./swaggerRoutes/labellaModule");
  if (!fs.existsSync(swaggerDir)) {
    fs.mkdirSync(swaggerDir);
  }
  const swaggerFilePath = path.join(
    swaggerDir,
    `${modelName.toLowerCase()}.yaml`
  );
  fs.writeFileSync(swaggerFilePath, swaggerContent.trim(), "utf8");
  console.log(
    `Swagger specs generated for ${modelName} and saved to ${swaggerFilePath}`
  );
});

export default routerStand;
